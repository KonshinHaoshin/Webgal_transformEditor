import { useEffect, useRef, useState } from "react";
import "./transform-editor.css";
import { TransformData } from "./types/transform.ts";
import { exportScript, parseScript } from "./utils/transformParser.ts";
import CanvasRenderer from "./components/CanvasRenderer.tsx";
import RotationPanel from "./components/RotationPanel";
import Modal from "./components/Modal";
import FilterEditor from "./components/FilterEditor";
import { GuideLineType } from "./types/guideLines";


export default function TransformEditor() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [input, setInput] = useState("");
  const [transforms, setTransforms] = useState<TransformData[]>([]);
  const [dragging] = useState<number | null>(null);
  const [modelImg, setModelImg] = useState<HTMLImageElement | null>(null);
  const [selectedIndexes, setSelectedIndexes] = useState<number[]>([]);
  const [, setAllSelected] = useState(false);
  const [lockX, setLockX] = useState(false);
  const [lockY, setLockY] = useState(false);
  const [exportDuration, setExportDuration] = useState(500);
  const [ease, setEase] = useState<string>("easeInOut");
  const [bgImg, setBgImg] = useState<HTMLImageElement | null>(null);
  const bgBaseScaleRef = useRef<{ x: number; y: number }>({ x: 1, y: 1 });
  const [mousePos, setMousePos] = useState<{ x: number; y: number } | null>(null);
  const [filterPresets, setFilterPresets] = useState<Record<string, any>>({});
  const [enableFilterPreset, setEnableFilterPreset] = useState(true);
  const [lastAppliedPresetKeys, setLastAppliedPresetKeys] = useState<string[]>([]);
  const [applyFilterToBg, setApplyFilterToBg] = useState(false);
  const [openFilterModal, setOpenFilterModal] = useState(false);
  const [guideLineType, setGuideLineType] = useState<GuideLineType>('none');
  
  // Âä®ÁîªÊí≠ÊîæÁõ∏ÂÖ≥Áä∂ÊÄÅ
  const [isPlaying, setIsPlaying] = useState(false);
  const [animationStartTime, setAnimationStartTime] = useState<number | null>(null);
  const [animationData, setAnimationData] = useState<any[]>([]);

  const canvasWidth = 2560;
  const canvasHeight = 1440;
  const baseWidth = 2560;
  const baseHeight = 1440;
  const scaleX = canvasWidth / baseWidth;
  const scaleY = canvasHeight / baseHeight;

  const modelOriginalWidth = 741;
  const modelOriginalHeight = 1123;
  const scaleModel = 1;
  const modelWidth = modelOriginalWidth * scaleModel;
  const modelHeight = modelOriginalHeight * scaleModel;

  function nextFigureName(list: TransformData[]) {
    let max = 0;
    for (const t of list) {
      const m = /^figure(\d+)$/.exec(t.target);
      if (m) max = Math.max(max, parseInt(m[1], 10));
    }
    return `figure${max + 1}`;
  }



  // ÁúüÊ≠£ÁöÑÂä®ÁîªÊí≠ÊîæÂäüËÉΩ
  const playAnimation = () => {
    if (transforms.length === 0) {
      alert("ËØ∑ÂÖàÊ∑ªÂä†‰∏Ä‰∫õÂèòÊç¢ÂêéÂÜçÊí≠ÊîæÂä®Áîª");
      return;
    }

    // ËøáÊª§Âá∫ÊâÄÊúâÁöÑ setTransform È°πÁõÆ
    const setTransformItems = transforms.filter(t => t.type === 'setTransform');
    
    if (setTransformItems.length === 0) {
      alert("‚ö†Ô∏è Ê≤°ÊúâÊâæÂà∞‰ªª‰Ωï setTransform Êåá‰ª§ÔºåÊó†Ê≥ïÊí≠ÊîæÂä®Áîª");
      return;
    }

    // ÈªòËÆ§Ëµ∑ÂßãÁä∂ÊÄÅ
    const defaultState = {
      position: { x: 0, y: 0 },
      rotation: 0,
      scale: { x: 1, y: 1 }
    };

    // ‰øÆÂ§ç playAnimation ÂáΩÊï∞‰∏≠ÁöÑ ease Â§ÑÁêÜÈÄªËæë
    const newAnimationData = setTransformItems.map((transform) => {
      const target = transform.target;
      const duration = exportDuration;
      // Â¶ÇÊûú transform ÊúâËá™Â∑±ÁöÑ easeÔºå‰ΩøÁî®ÂÆÉÔºõÂê¶Âàô‰ΩøÁî®ÂÖ®Â±Ä ease
      let ease = transform.ease;
      if (!ease || ease === "" || ease === "default") {
        ease = ""; // Á©∫Â≠óÁ¨¶‰∏≤Ë°®Á§∫‰ΩøÁî®ÂÖ®Â±ÄËÆæÁΩÆ
      }
      
      return {
        target,
        duration,
        ease,
        startState: defaultState,
        endState: transform.transform,
        startTime: 0,
        endTime: duration
      };
    });

    // ËÆæÁΩÆÂä®ÁîªÊï∞ÊçÆÂπ∂ÂºÄÂßãÊí≠Êîæ
    setAnimationData(newAnimationData);
    setIsPlaying(true);
    setAnimationStartTime(Date.now());
    
    console.log("üé¨ ÂºÄÂßãÊí≠ÊîæÂä®Áîª:", newAnimationData);
  };

  // ÂÅúÊ≠¢Âä®Áîª
  const stopAnimation = () => {
    setIsPlaying(false);
    setAnimationStartTime(null);
    setAnimationData([]);
    console.log("‚èπÔ∏è Âä®ÁîªÂ∑≤ÂÅúÊ≠¢");
  };

  // ÁºìÂä®ÂáΩÊï∞ÂÆûÁé∞ - ÂÆåÂÖ®ÂåπÈÖç popmotion
  const easeFunctions = {
    easeInOut: (t: number) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    easeIn: (t: number) => t * t,
    easeOut: (t: number) => t * (2 - t),
    circInOut: (t: number) => t < 0.5 ? 0.5 * (1 - Math.cos(Math.PI * t)) : 0.5 * (1 + Math.cos(Math.PI * (t - 1))),
    circIn: (t: number) => 1 - Math.sqrt(1 - t * t),
    circOut: (t: number) => Math.sqrt(1 - (t - 1) * (t - 1)),
    backInOut: (t: number) => t < 0.5 ? 0.5 * (2 * t * t * (3.5949095 * t - 2.5949095)) : 0.5 * (2 * (t - 1) * (t - 1) * (3.5949095 * (t - 1) + 2.5949095) + 1),
    backIn: (t: number) => t * t * (2.5949095 * t - 1.5949095),
    backOut: (t: number) => (t - 1) * (t - 1) * (2.5949095 * (t - 1) + 1.5949095) + 1,
    bounceInOut: (t: number) => {
      if (t < 0.5) return 0.5 * (1 - easeFunctions.bounceOut(1 - 2 * t));
      return 0.5 * easeFunctions.bounceOut(2 * t - 1) + 0.5;
    },
    bounceIn: (t: number) => 1 - easeFunctions.bounceOut(1 - t),
    bounceOut: (t: number) => {
      if (t < 1 / 2.75) return 7.5625 * t * t;
      if (t < 2 / 2.75) return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
      if (t < 2.5 / 2.75) return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    },
    linear: (t: number) => t,
    anticipate: (t: number) => t * t * (2.70158 * t - 1.70158)
  };

  // ËÆ°ÁÆóÂΩìÂâçÂä®ÁîªÁä∂ÊÄÅ
  const getCurrentAnimationState = () => {
    if (!isPlaying || !animationStartTime || animationData.length === 0) {
      return null;
    }

    const currentTime = Date.now() - animationStartTime;
    const maxDuration = Math.max(...animationData.map(a => a.duration));
    
    if (currentTime >= maxDuration) {
      // Âä®ÁîªÁªìÊùü
      setIsPlaying(false);
      setAnimationStartTime(null);
      return null;
    }

         // ËÆ°ÁÆóÊØè‰∏™ÁõÆÊ†áÁöÑÂΩìÂâçÁä∂ÊÄÅ
     return animationData.map(animation => {
       const { target, startState, endState, duration, ease } = animation;
       const elapsed = Math.min(currentTime, duration);
       const progress = elapsed / duration;
       
               // Â∫îÁî®ÁºìÂä®ÂáΩÊï∞ - Á°Æ‰øù ease ÂÄºÊúâÊïà
        let easedProgress = progress;
        if (ease && ease !== "" && easeFunctions[ease as keyof typeof easeFunctions]) {
          // ‰ΩøÁî® transform Ëá™Â∑±ÁöÑ ease
          easedProgress = easeFunctions[ease as keyof typeof easeFunctions](progress);
        } else {
          // ‰ΩøÁî®ÂÖ®Â±Ä ease
          if (easeFunctions[ease as keyof typeof easeFunctions]) {
            easedProgress = easeFunctions[ease as keyof typeof easeFunctions](progress);
          }
        }
      
      // ÊèíÂÄºËÆ°ÁÆóÂΩìÂâç‰ΩçÁΩÆ
      const currentPosition = {
        x: startState.position.x + (endState.position.x - startState.position.x) * easedProgress,
        y: startState.position.y + (endState.position.y - startState.position.y) * easedProgress
      };
      
      // ÊèíÂÄºËÆ°ÁÆóÂΩìÂâçÁº©Êîæ
      const currentScale = {
        x: startState.scale.x + (endState.scale.x - startState.scale.x) * easedProgress,
        y: startState.scale.y + (endState.scale.y - startState.scale.y) * easedProgress
      };
      
      // ÊèíÂÄºËÆ°ÁÆóÂΩìÂâçÊóãËΩ¨
      const currentRotation = startState.rotation + (endState.rotation - startState.rotation) * easedProgress;
      
      // ÊèíÂÄºËÆ°ÁÆóÊª§ÈïúÊïàÊûú
      const currentFilters: any = {};
      if (endState.brightness !== undefined) {
        currentFilters.brightness = endState.brightness; 
      }
      if (endState.contrast !== undefined) {
        currentFilters.contrast = endState.contrast; 
      }
      if (endState.saturation !== undefined) {
        currentFilters.saturation = endState.saturation; 
      }
      if (endState.gamma !== undefined) {
        currentFilters.gamma = endState.gamma; 
      }
      if (endState.colorRed !== undefined) {
        currentFilters.colorRed = endState.colorRed; 
      }
      if (endState.colorGreen !== undefined) {
        currentFilters.colorGreen = endState.colorGreen; 
      }
      if (endState.colorBlue !== undefined) {
        currentFilters.colorBlue = endState.colorBlue; 
      }
      if (endState.bloom !== undefined) {
        currentFilters.bloom = endState.bloom; 
      }
      if (endState.bloomBrightness !== undefined) {
        currentFilters.bloomBrightness = endState.bloomBrightness; 
      }
      if (endState.bloomBlur !== undefined) {
        currentFilters.bloomBlur = endState.bloomBlur; 
      }
      if (endState.bevel !== undefined) {
        currentFilters.bevel = endState.bevel; 
      }
      if (endState.bevelThickness !== undefined) {
        currentFilters.bevelThickness = endState.bevelThickness; 
      }
      if (endState.bevelRotation !== undefined) {
        currentFilters.bevelRotation = endState.bevelRotation; 
      }
      if (endState.bevelRed !== undefined) {
        currentFilters.bevelRed = endState.bevelRed; 
      }
      if (endState.bevelGreen !== undefined) {
        currentFilters.bevelGreen = endState.bevelGreen; 
      }
      if (endState.bevelBlue !== undefined) {
        currentFilters.bevelBlue = endState.bevelBlue; 
      }

      return {
        target,
        transform: {
          position: currentPosition,
          scale: currentScale,
          rotation: currentRotation,
          ...currentFilters
        }
      };
    });
  };

  useEffect(() => {
    const model = new Image();
    model.src = "./assets/sakiko_girlfriend.png";
    model.onload = () => setModelImg(model);

    const bg = new Image();
    bg.src = "./assets/bg.png";
    bg.onload = () => setBgImg(bg);
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const handleMove = (e: MouseEvent) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvasWidth / rect.width);
      const my = (e.clientY - rect.top) * (canvasHeight / rect.height);
      const logicX = (mx - canvasWidth / 2) / scaleX;
      const logicY = (my - canvasHeight / 2) / scaleY;
      setMousePos({ x: logicX, y: logicY });
    };
    const handleLeave = () => setMousePos(null);

    canvas.addEventListener("mousemove", handleMove);
    canvas.addEventListener("mouseleave", handleLeave);
    return () => {
      canvas.removeEventListener("mousemove", handleMove);
      canvas.removeEventListener("mouseleave", handleLeave);
    };
  }, [canvasRef.current, canvasWidth, canvasHeight]);

  useEffect(() => {}, [transforms, dragging, modelImg]);

  // Âä®ÁîªÂæ™ÁéØ
  useEffect(() => {
    if (!isPlaying) return;

    const animationLoop = () => {
      const currentState = getCurrentAnimationState();
      if (currentState) {
        // Êõ¥Êñ∞ transforms ‰ª•ÊòæÁ§∫ÂΩìÂâçÂä®ÁîªÁä∂ÊÄÅ
        setTransforms(prev => {
          const newTransforms = [...prev];
          currentState.forEach(animState => {
            const index = newTransforms.findIndex(t => t.target === animState.target);
            if (index !== -1) {
              newTransforms[index] = {
                ...newTransforms[index],
                transform: animState.transform
              };
            }
          });
          return newTransforms;
        });
        
        // ÁªßÁª≠Âä®ÁîªÂæ™ÁéØ
        requestAnimationFrame(animationLoop);
      }
    };

    requestAnimationFrame(animationLoop);
  }, [isPlaying, animationData, animationStartTime]);

  useEffect(() => {
    fetch("/filter-presets.json")
      .then((res) => res.json())
      .then((data) => setFilterPresets(data))
      .catch((err) => console.error("‚ùå Failed to load filter presets:", err));
  }, []);





  return (
    <div
      className="transform-editor-container"
      style={{ maxHeight: "100vh", overflowY: "auto", padding: "20px", boxSizing: "border-box" }}
    >
      <h2>EASTMOUNT WEBGAL TRANSFORM EDITOR</h2>

      <p
        style={{
          backgroundColor: "#eef6ff",
          color: "#333",
          padding: "10px 14px",
          borderRadius: "6px",
          fontSize: "14px",
          border: "1px solid #cde1f9",
          maxWidth: 780,
          margin: "10px auto",
        }}
      >
        üí° <strong>Êìç‰ΩúÊèêÁ§∫Ôºö</strong>
        <br />„ÉªCtrl + ÊªöËΩÆÔºöÁº©ÊîæÊ®°Âûã/ËÉåÊôØ
        <br />„ÉªAlt + ÊãñÂä®ÔºöÊóãËΩ¨ÈÄâ‰∏≠ÂØπË±°
        <br />„ÉªShift + ÁÇπÂáªÔºöÂ§öÈÄâÂØπË±°
        <br />„ÉªÂÖ≥Ê≥® <strong>‰∏úÂ±±ÁáÉÁÅØÂØ∫</strong> Ë∞¢Ë∞¢Âñµ~
      </p>

      <textarea
        style={{ width: 1080, height: 100 }}
        placeholder="Paste your setTransform script here"
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      <br />
             <button
         onClick={() => {
           const parsed = parseScript(input, scaleX, scaleY).map((t) => {
             const { __presetApplied, ...rest } = t as any;
             return rest;
           });
           if (parsed.length === 0) alert("‚ö†Ô∏è Ê≤°ÊúâËß£ÊûêÂà∞‰ªª‰Ωï setTransform Êåá‰ª§ÔºÅ");
           
                       // Ê£ÄÊµãÂØºÂÖ•ÁöÑËÑöÊú¨‰∏≠ÁöÑ ease ÂÄºÔºåÂπ∂Êõ¥Êñ∞ÂÖ®Â±ÄËÆæÁΩÆ
            const setTransformItems = parsed.filter(t => t.type === 'setTransform');
            if (setTransformItems.length > 0) {
              // Â¶ÇÊûúÂ≠òÂú® setTransformÔºå‰ΩøÁî®Á¨¨‰∏Ä‰∏™ÁöÑ ease ÂÄº‰Ωú‰∏∫ÂÖ®Â±ÄÈªòËÆ§ÂÄº
              const firstEase = setTransformItems[0].ease;
              if (firstEase && firstEase !== "") {
                setEase(firstEase);
                console.log(`üéØ Ê£ÄÊµãÂà∞ÂØºÂÖ•ËÑöÊú¨ÁöÑ ease ÂÄº: ${firstEase}ÔºåÂ∑≤Êõ¥Êñ∞ÂÖ®Â±ÄËÆæÁΩÆ`);
              }
            }
           
           setTransforms(parsed);
           setAllSelected(false);
           setSelectedIndexes([]);
         }}
       >
         Load Script
       </button>
      <button
        onClick={() => {
          const script = exportScript(transforms, exportDuration, canvasWidth, canvasHeight, baseWidth, baseHeight);
          navigator.clipboard.writeText(script);
          alert("Script copied!");
        }}
      >
        Copy Output Script
      </button>
      <button
        onClick={() => {
          setSelectedIndexes(transforms.map((_, i) => i));
          setAllSelected(true);
        }}
      >
        Select All
      </button>
      <button
        onClick={() => {
          setSelectedIndexes([]);
          setAllSelected(false);
        }}
      >
        Deselect All
      </button>

      <button
        onClick={() => {
          const name = nextFigureName(transforms);
          const newItem: TransformData = {
            type: "setTransform",
            target: name,
            duration: 0,
            transform: { position: { x: 0, y: 0 }, scale: { x: 1, y: 1 } },
          };
          (newItem as any).presetPosition = "center";
          setTransforms((prev) => [...prev, newItem]);
          setSelectedIndexes([transforms.length]);
        }}
      >
        + Add setTransform
      </button>

      <div style={{ margin: "10px 0" }}>
        <label>
          <input type="checkbox" checked={lockX} onChange={() => setLockX(!lockX)} />
          Lock X
        </label>
        <label style={{ marginLeft: 10 }}>
          <input type="checkbox" checked={lockY} onChange={() => setLockY(!lockY)} />
          Lock Y
        </label>
        <label style={{ marginLeft: 20 }}>
          Export Duration:
          <input
            type="number"
            value={exportDuration}
            onChange={(e) => setExportDuration(Number(e.target.value))}
            style={{ width: 80, marginLeft: 5 }}
          />
        </label>
                 <label style={{ marginLeft: 20 }}>
           Ease:
           <select
             value={ease}
             onChange={(e) => {
               const newEase = e.target.value;
               setEase(newEase);
               
               // ÂêåÊ≠•Êõ¥Êñ∞ÊâÄÊúâÊ≤°ÊúâËÆæÁΩÆeaseÁöÑtransformÂØπË±°
               setTransforms((prev) => {
                 return prev.map((transform) => {
                   if (!transform.ease || transform.ease === "" || transform.ease === "default") {
                     return { ...transform, ease: newEase };
                   }
                   return transform;
                 });
               });
             }}
             style={{ marginLeft: 5 }}
           >
             <option value="default">ÈªòËÆ§</option>
             <option value="easeInOut">ÁºìÂÖ•ÁºìÂá∫</option>
             <option value="easeIn">ÁºìÂÖ•</option>
             <option value="easeOut">ÁºìÂá∫</option>
             <option value="circInOut">ÂúÜÂΩ¢ÁºìÂÖ•ÁºìÂá∫</option>
             <option value="circIn">ÂúÜÂΩ¢ÁºìÂÖ•</option>
             <option value="circOut">ÂúÜÂΩ¢ÁºìÂá∫</option>
             <option value="backInOut">Ëµ∑Ê≠¢ÂõûÂºπ</option>
             <option value="backIn">Ëµ∑ÁÇπÂõûÂºπ</option>
             <option value="backOut">ÁªàÁÇπÂõûÂºπ</option>
             <option value="bounceInOut">Ëµ∑Ê≠¢ÂºπË∑≥</option>
             <option value="bounceIn">Ëµ∑ÁÇπÂºπË∑≥</option>
             <option value="bounceOut">ÁªàÁÇπÂºπË∑≥</option>
             <option value="linear">Á∫øÊÄß</option>
             <option value="anticipate">È¢ÑÂÖàÂèçÂêë</option>
           </select>
         </label>
         
         <label style={{ marginLeft: 20 }}>
           ËæÖÂä©Á∫ø:
           <select
             value={guideLineType}
             onChange={(e) => setGuideLineType(e.target.value as GuideLineType)}
             style={{ marginLeft: 5 }}
           >
             <option value="none">Êó†ËæÖÂä©Á∫ø</option>
             <option value="grid-3x3">‰πùÂÆ´Ê†º</option>
             <option value="rule-of-thirds">‰∏âÂàÜÊ≥ï</option>
             <option value="center-cross">‰∏≠ÂøÉÂçÅÂ≠ó</option>
             <option value="diagonal">ÂØπËßíÁ∫ø</option>
             <option value="golden-ratio">ÈªÑÈáëÊØî‰æã</option>
           </select>
         </label>
      </div>

      <div style={{ marginTop: 20 }}>
                 <div style={{ display: "flex", alignItems: "center", gap: "12px", flexWrap: "wrap", justifyContent: "center" }}>
          <label>
            <input
              type="checkbox"
              checked={enableFilterPreset}
              onChange={(e) => {
                const checked = e.target.checked;
                setEnableFilterPreset(checked);
                if (!checked) {
                  setTransforms((prev) =>
                    prev.map((t) => {
                      const updated = { ...t.transform };
                      lastAppliedPresetKeys.forEach((key) => {
                        if (key in updated) delete updated[key];
                      });
                      return { ...t, transform: updated };
                    })
                  );
                  setLastAppliedPresetKeys([]);
                }
              }}
            />
            Â∫îÁî®Êª§ÈïúÈ¢ÑËÆæ
          </label>

          <label>
            <input type="checkbox" checked={applyFilterToBg} onChange={() => setApplyFilterToBg(!applyFilterToBg)} />
            ÂêåÊó∂‰ΩúÁî®‰∫éËÉåÊôØ
          </label>

          

                     {/* ÂÜÖÂµåÊÇ¨ÊµÆÈù¢ÊùøÔºà‰∏çÂèòÊöóÔºâ */}
           <button onClick={() => setOpenFilterModal(true)}>ÊâìÂºÄÊª§ÈïúÁºñËæëÂô®</button>
           
                       

            {/* Êí≠Êîæ/ÂÅúÊ≠¢Âä®ÁîªÊåâÈíÆ */}
            {!isPlaying ? (
              <button 
                onClick={playAnimation}
                style={{
                  background: "#3b82f6",
                  color: "white",
                  border: "none",
                  padding: "8px 16px",
                  borderRadius: "4px",
                  cursor: "pointer",
                  fontSize: "14px"
                }}
              >
                ‚ñ∂Ô∏è Êí≠ÊîæÂä®Áîª
              </button>
            ) : (
              <button 
                onClick={stopAnimation}
                style={{
                  background: "#ef4444",
                  color: "white",
                  border: "none",
                  padding: "8px 16px",
                  borderRadius: "4px",
                  cursor: "pointer",
                  fontSize: "14px"
                }}
              >
                ‚èπÔ∏è ÂÅúÊ≠¢Âä®Áîª
              </button>
            )}
        </div>

        <label style={{ marginTop: 10, display: "block" }}>ÈÄâÊã©È¢ÑËÆæÔºö</label>
        <select
          onChange={(e) => {
            const preset = filterPresets[e.target.value];
            if (!preset) return;
            if (!enableFilterPreset) {
              alert("ËØ∑ÂÖàÂãæÈÄâ‚ÄúÂ∫îÁî®Êª§ÈïúÈ¢ÑËÆæ‚ÄùÂÜç‰ΩøÁî®");
              return;
            }
            const keys = Object.keys(preset);
            setLastAppliedPresetKeys(keys);
            setTransforms((prev) =>
              prev.map((t) => {
                if (t.target === "bg-main" && !applyFilterToBg) return t;
                const newTransform = {
                  position: t.transform.position || { x: 0, y: 0 },
                  scale: t.transform.scale || { x: 1, y: 1 },
                  rotation: t.transform.rotation || 0,
                };
                return { ...t, transform: { ...newTransform, ...preset } };
              })
            );
          }}
          defaultValue=""
        >
          <option value="" disabled>
            ÈÄâÊã©‰∏Ä‰∏™È¢ÑËÆæ...
          </option>
          {Object.keys(filterPresets).map((key) => (
            <option key={key} value={key}>
              {key}
            </option>
          ))}
        </select>
      </div>

      <div style={{ display: "flex", justifyContent: "center", marginTop: 20, position: "relative" }}>
        <canvas
          ref={canvasRef}
          width={canvasWidth}
          height={canvasHeight}
          style={{
            width: "100%",
            height: "auto",
            maxHeight: 450,
            maxWidth: 800,
            border: "1px solid red",
            backgroundColor: "#f8f8f8",
          }}
        />
        
        
        {mousePos && (
          <div
            style={{
              position: "fixed",
              top: 10,
              left: 10,
              backgroundColor: "rgba(0, 0, 0, 0.7)",
              color: "#fff",
              padding: "6px 10px",
              borderRadius: 4,
              fontSize: 12,
              zIndex: 1000,
              pointerEvents: "none",
            }}
          >
            Mouse: (x: {mousePos.x.toFixed(1)}, y: {mousePos.y.toFixed(1)})
          </div>
        )}
        <CanvasRenderer
          canvasRef={canvasRef}
          transforms={transforms}
          setTransforms={setTransforms}
          selectedIndexes={selectedIndexes}
          setSelectedIndexes={setSelectedIndexes}
          modelImg={modelImg}
          bgImg={bgImg}
          baseWidth={baseWidth}
          baseHeight={baseHeight}
          canvasWidth={canvasWidth}
          canvasHeight={canvasHeight}
          modelOriginalWidth={modelWidth}
          modelOriginalHeight={modelHeight}
          bgBaseScaleRef={bgBaseScaleRef}
          lockX={lockX}
          lockY={lockY}
          guideLineType={guideLineType}
        />
      </div>

      {selectedIndexes.length > 0 && (
        <div style={{ marginTop: 20 }}>
          <RotationPanel
            transforms={transforms}
            selectedIndexes={selectedIndexes}
            onChange={(index, newRotation) => {
              setTransforms((prev) => {
                const copy = [...prev];
                copy[index] = { ...copy[index], transform: { ...copy[index].transform, rotation: newRotation } };
                return copy;
              });
            }}
            onChangeTarget={(index, newTarget) => {
              setTransforms((prev) => {
                const copy = [...prev];
                copy[index] = { ...copy[index], target: newTarget };
                return copy;
              });
            }}
            onChangeEase={(index, newEase) => {
              setTransforms((prev) => {
                const copy = [...prev];
                copy[index] = { ...copy[index], ease: newEase };
                return copy;
              });
            }}
            onChangeScale={(index, axis, newScale) => {
              setTransforms((prev) => {
                const copy = [...prev];
                if (!copy[index].transform.scale) {
                  copy[index].transform.scale = { x: 1, y: 1 };
                }
                if (axis === 'x') {
                  copy[index].transform.scale.x = newScale;
                } else {
                  copy[index].transform.scale.y = newScale;
                }
                return copy;
              });
            }}
            onChangeId={() => {}}
          />

          {/* ÂÜÖÂµåÊÇ¨ÊµÆÊª§ÈïúÁºñËæëÂô®Ôºà‰∏ç‰ºöËÆ©‰∏ªÁºñËæëÂô®ÂèòÊöóÔºâ */}
          <Modal
            isOpen={openFilterModal}
            onClose={() => setOpenFilterModal(false)}
            title="Êª§ÈïúÁºñËæëÂô®"
            width={500}
            variant="floating"
            draggable
            resizable
            disableBackdrop
            mountToBody
            initialPosition={{ x: 96, y: 96 }}
          >
            <FilterEditor
              transforms={transforms}
              setTransforms={setTransforms}
              selectedIndexes={selectedIndexes}
              applyFilterToBg={applyFilterToBg}
              setApplyFilterToBg={setApplyFilterToBg}
            />
          </Modal>
        </div>
      )}

             <h3>Output Script:</h3>
       <pre>{exportScript(transforms, exportDuration, canvasWidth, canvasHeight, baseWidth, baseHeight, ease === "default" ? undefined : ease)}</pre>
    </div>
  );
}
